<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Extension Category | uwkit&#39;site</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Extension 拓展/匿名分类是在编译期决议，作为类的一部分。它在编译期和头文件里以及实现文件中的内容一起形成一个完整的类。 特点 可以声明方法、属性、成员变量 一般用于声明私有方法、私有属性、私有成员变量 只存在于一个.h文件中，或只寄生于一个类的.m文件中，例如@interface ViewController () ... @end（常用） 必须要有一个类的源码才能添加一个类的拓展，对于">
<meta property="og:type" content="article">
<meta property="og:title" content="Extension Category">
<meta property="og:url" content="http://yoursite.com/2018/06/03/Extension Category/index.html">
<meta property="og:site_name" content="uwkit&#39;site">
<meta property="og:description" content="Extension 拓展/匿名分类是在编译期决议，作为类的一部分。它在编译期和头文件里以及实现文件中的内容一起形成一个完整的类。 特点 可以声明方法、属性、成员变量 一般用于声明私有方法、私有属性、私有成员变量 只存在于一个.h文件中，或只寄生于一个类的.m文件中，例如@interface ViewController () ... @end（常用） 必须要有一个类的源码才能添加一个类的拓展，对于">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-06-03T09:05:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Extension Category">
<meta name="twitter:description" content="Extension 拓展/匿名分类是在编译期决议，作为类的一部分。它在编译期和头文件里以及实现文件中的内容一起形成一个完整的类。 特点 可以声明方法、属性、成员变量 一般用于声明私有方法、私有属性、私有成员变量 只存在于一个.h文件中，或只寄生于一个类的.m文件中，例如@interface ViewController () ... @end（常用） 必须要有一个类的源码才能添加一个类的拓展，对于">
  
    <link rel="alternate" href="/atom.xml" title="uwkit&#39;site" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css">
  
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-Extension Category" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
    <div class="mobile-nav">
      <h1 class="nickname">uwkit</h1>
      <a id="menu">
        &#9776; Menu
      </a>
    </div>
    
        <nav id="main-nav" class="main-nav">
    
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Extension Category
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h5 id="Extension-拓展-匿名分类"><a href="#Extension-拓展-匿名分类" class="headerlink" title="Extension 拓展/匿名分类"></a>Extension 拓展/匿名分类</h5><p>是在编译期决议，作为类的一部分。它在编译期和头文件里以及实现文件中的内容一起形成一个完整的类。</p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul>
<li>可以声明方法、属性、成员变量</li>
<li>一般用于声明私有方法、私有属性、私有成员变量</li>
<li>只存在于一个.h文件中，或只寄生于一个类的.m文件中，例如<code>@interface ViewController () ... @end</code>（常用）</li>
<li>必须要有一个类的源码才能添加一个类的拓展，对于一些系统的类，可以通过创建子类添加拓展</li>
</ul>
<hr>
<h5 id="Category-分类-类别"><a href="#Category-分类-类别" class="headerlink" title="Category 分类/类别"></a>Category 分类/类别</h5><p>是在运行时决议，在不改变原有类的情况下，动态地进行方法_协议_属性的添加，以适应不同情况下的需求。</p>
<h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><ul>
<li>可以添加实例方法、类方法，甚至可以实现协议、添加属性（不会生成 setter / getter 方法）</li>
<li>不可以添加实例变量</li>
<li>一般用于声明私有方法、私有属性、私有成员变量</li>
<li>只存在于一个.h文件中，或只寄生于一个类的.m文件中，例如<code>@interface ViewController () ... @end</code>（常用）</li>
<li>必须要有一个类的源码才能添加一个类的拓展，对于一些系统的类，可以通过创建子类添加拓展</li>
</ul>
<h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><ul>
<li>给现有的类添加方法</li>
<li>把类的实现根据不同功能组织分开在几个不同的文件中，减少单个文件的体积，按需加载</li>
<li>声明私有方法</li>
</ul>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>不建议复写系统类的方法。添加的方法和类中原有的方法同名时，category 会优先调用 category 中的方法。（两者同时存在于方法列表中，在运行时方法的调用由编译器决定，最后参与编译的会被调用）优先级为 分类 &gt; 本类 &gt; 父类。<br>严格意义上来讲，category 中的 load 同普通方法也会对主类中的 load 造成覆盖，只不过 runtime 在自动调用主类和分类中的 load 是直接使用各自方法的指针进行调用的（手动调用时调用的则是分类中的 load 方法）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//分类结构体 可以添加实例方法、类方法，甚至可以实现协议、添加属性</span><br><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line">	 </span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>加载分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _read_images</span><br><span class="line">* Perform initial processing of the headers in the linked </span><br><span class="line">* list beginning with headerList. </span><br><span class="line">*</span><br><span class="line">* Called by: map_images_nolock</span><br><span class="line">*</span><br><span class="line">* Locking: runtimeLock acquired by map_images</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // Discover categories. </span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process this category. </span><br><span class="line">            // First, register the category with its target class. 将 category 和它的主类/父类注册到哈希表中</span><br><span class="line">            // Then, rebuild the class&apos;s method lists (etc) if  the class is realized. 如果主类/父类已经实现，重建它的方法列表</span><br><span class="line">			  // 协议被同时整合到主类和元类</span><br><span class="line">	  	      // 主类对应实例方法和属性，元类对应类方法</span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(&quot;IMAGE TIMES: discover categories&quot;);</span><br><span class="line"></span><br><span class="line">    // Category discovery MUST BE LAST to avoid potential races </span><br><span class="line">    // when other threads call the new category code before </span><br><span class="line">    // this thread finishes its fixups.</span><br><span class="line"></span><br><span class="line">    // +load handled by prepare_load_methods()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取分类后进行处理</p>
</li>
</ol>
<ul>
<li><p>调用 <code>addUnattachedCategoryForClass</code>获取未整合到本类的分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* addUnattachedCategoryForClass</span><br><span class="line">* Records an unattached category.</span><br><span class="line">* Locking: runtimeLock must be held by the caller.</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void addUnattachedCategoryForClass(category_t *cat, Class cls, </span><br><span class="line">                                          header_info *catHeader)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span><br><span class="line">	  // 取得存储所有未整合分类的列表</span><br><span class="line">    NXMapTable *cats = unattachedCategories();</span><br><span class="line">    category_list *list;</span><br><span class="line"></span><br><span class="line">	  // 取得 cls 对应的未整合分类的列表</span><br><span class="line">    list = (category_list *)NXMapGet(cats, cls);</span><br><span class="line">    if (!list) &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1));</span><br><span class="line">    &#125;</span><br><span class="line">	  // 将取得的新的分类 cat 添加到刚开辟出来的位置</span><br><span class="line">    list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;;</span><br><span class="line">	  // 将新的 list 插入 cats 中，覆盖掉旧的 list</span><br><span class="line">    NXMapInsert(cats, cls, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>remethodizeClass</code>重新整理类的数据，通过 cls-&gt;ISA() 得到上面新的 list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* remethodizeClass</span><br><span class="line">* Attach outstanding categories to an existing class.</span><br><span class="line">* Fixes up cls&apos;s method list, protocol list, and property list. 整合方法/属性/协议</span><br><span class="line">* Updates method caches for cls and its subclasses. 更新类的数据字段</span><br><span class="line">* Locking: runtimeLock must be held by the caller</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">	  // unattachedCategoriesForClass 取得 cls 中未整合的分类列表</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		  // 将为整合的分类整合到类上</span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.下面从这个方法 <code>attachCategories(cls, cats, true /*flush caches*/);</code>开始看，是真正进行处理的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">fixupMethodList(method_list_t *mlist, bool bundleCopy, bool sort)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    assert(!mlist-&gt;isFixedUp());</span><br><span class="line"></span><br><span class="line">    // fixme lock less in attachMethodLists ?</span><br><span class="line">    sel_lock();</span><br><span class="line">    </span><br><span class="line">    // Unique selectors in list.</span><br><span class="line">    for (auto&amp; meth : *mlist) &#123;</span><br><span class="line">        const char *name = sel_cname(meth.name);</span><br><span class="line">        meth.name = sel_registerNameNoLock(name, bundleCopy);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sel_unlock();</span><br><span class="line"></span><br><span class="line">    // Sort by selector address.</span><br><span class="line">    if (sort) &#123;</span><br><span class="line">        method_t::SortBySELAddress sorter;</span><br><span class="line">        std::stable_sort(mlist-&gt;begin(), mlist-&gt;end(), sorter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Mark method list as uniqued and sorted</span><br><span class="line">    mlist-&gt;setFixedUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void </span><br><span class="line">prepareMethodLists(Class cls, method_list_t **addedLists, int addedCount, </span><br><span class="line">                   bool baseMethods, bool methodsFromBundle)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">    // Don&apos;t scan redundantly</span><br><span class="line">    bool scanForCustomRR = !cls-&gt;hasCustomRR();</span><br><span class="line">    bool scanForCustomAWZ = !cls-&gt;hasCustomAWZ();</span><br><span class="line"></span><br><span class="line">    // There exist RR/AWZ special cases for some class&apos;s base methods. </span><br><span class="line">    // But this code should never need to scan base methods for RR/AWZ: </span><br><span class="line">    // default RR/AWZ cannot be set before setInitialized().</span><br><span class="line">    // Therefore we need not handle any special cases here.</span><br><span class="line">    if (baseMethods) &#123;</span><br><span class="line">        assert(!scanForCustomRR  &amp;&amp;  !scanForCustomAWZ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Add method lists to array.</span><br><span class="line">    // Reallocate un-fixed method lists.</span><br><span class="line">    // The new methods are PREPENDED to the method list array.</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; addedCount; i++) &#123;</span><br><span class="line">        method_list_t *mlist = addedLists[i];</span><br><span class="line">        assert(mlist);</span><br><span class="line"></span><br><span class="line">        // Fixup selectors if necessary</span><br><span class="line">        if (!mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">            fixupMethodList(mlist, methodsFromBundle, true/*sort*/);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Scan for method implementations tracked by the class&apos;s flags</span><br><span class="line">        if (scanForCustomRR  &amp;&amp;  methodListImplementsRR(mlist)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomRR();</span><br><span class="line">            scanForCustomRR = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (scanForCustomAWZ  &amp;&amp;  methodListImplementsAWZ(mlist)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomAWZ();</span><br><span class="line">            scanForCustomAWZ = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Attach method lists and properties and protocols from categories to a class. 将类中的方法和分类中新添加的方法/属性/协议整合成到一个相应新的列表中</span><br><span class="line">// Assumes the categories in cats are all loaded and sorted by load order, oldest categories first. 按加载顺序进行排序，最旧的首先被加载，也就是存在复写时调用的是最后一个被加载的</span><br><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">	  // 主类对应实例方法和属性，元类对应类方法</span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">	  // 在堆上创建用来存储分类方法/属性/协议的列表</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">	  // 从后往前遍历，将它们放入各自的列表之中</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">	  // 从后开始，会先取到最新的分类</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	  // 取出 cls 中的 class_rw_t 数据</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">	  // 准备列表中方法 列表的数量 是否是基本方法 是否是来自Bundle</span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">	  // 添加到列表中</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">	  // 释放</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ul>
<li><p>属性<br>@property 声明的变量，在类中创建默认会自动生成一个以下划线为开头的成员变量以及 setter/getter 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//objc_property_t 是一个指向 objc_property 结构体的指针</span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">typedef struct property_t *objc_property_t;</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//获取所有属性</span><br><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">class_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">objc_property_t *</span><br><span class="line">class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        if (outCount) *outCount = 0;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwlock_reader_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    property_t **result = nil;</span><br><span class="line">    unsigned int count = rw-&gt;properties.count();</span><br><span class="line">    if (count &gt; 0) &#123;</span><br><span class="line">        result = (property_t **)malloc((count + 1) * sizeof(property_t *));</span><br><span class="line"></span><br><span class="line">        count = 0;</span><br><span class="line">        for (auto&amp; prop : rw-&gt;properties) &#123;</span><br><span class="line">            result[count++] = &amp;prop;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (outCount) *outCount = count;</span><br><span class="line">    return (objc_property_t *)result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//属性特性</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char * _Nonnull name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char * _Nonnull value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br><span class="line"></span><br><span class="line">//获取属性名</span><br><span class="line">property_getName</span><br><span class="line">//获取属性特性描述字符串</span><br><span class="line">property_getAttributes</span><br><span class="line">//获取所有属性特性</span><br><span class="line">property_copyAttributeList</span><br><span class="line">//获取相应属性特性的 value</span><br><span class="line">property_copyAttributeValue</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员变量<br>在 @interface 括号中的统称为成员变量，用于内部，无需与外界进行接触，因此它不会生成 setter/getter 方法。默认修饰是 assign （仅把目标内存区域指针赋值给变量，而内存区域的引用计数器不发生变化）</p>
</li>
<li><p>实例变量<br>是成员变量中的一种，是由类定义的变量。实例是针对类而言，是指类的声明。成员变量中除开基本数据类型（int/float..）变量，其他都是实例变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Ivar 指向一个 objc_ivar 结构体</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char * _Nullable ivar_name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    char * _Nullable ivar_type                               OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 获取指定名称的成员变量</span><br><span class="line">class_getInstanceVariable</span><br><span class="line">//@return A pointer to an \c Ivar data structure containing information about the class variable specified by \e name.</span><br><span class="line">class_getClassVariable</span><br><span class="line">// 获取所有成员变量</span><br><span class="line">class_copyIvarList</span><br><span class="line"></span><br><span class="line">// 获取成员变量名</span><br><span class="line">ivar_getName</span><br><span class="line">// 获取成员变量类型编码</span><br><span class="line">ivar_getTypeEncoding</span><br><span class="line">//获取实例变量的偏移值，当一个类被编译后，实例变量的内存布局就形成了（访问实例变量的位置），当系统检测到该类与父类发生重叠时就会调整新添加的实例变量的位置，以变量所占空间为依据产生位移。</span><br><span class="line">/**</span><br><span class="line">@note For instance variables of type \c id or other object types, call \c object_getIvar</span><br><span class="line"> *  and \c object_setIvar instead of using this offset to access the instance variable data directly.</span><br><span class="line">对于 id 或者其他对象类型的变量，调用 object_getIvar / object_setIvar 代替使用</span><br><span class="line">*/</span><br><span class="line">ivar_getOffset</span><br><span class="line"></span><br><span class="line">// 获取某个对象成员变量的值</span><br><span class="line">object_getIvar</span><br><span class="line">// 设置某个对象成员变量的值</span><br><span class="line">object_setIvar</span><br></pre></td></tr></table></figure>
</li>
<li><p>nonatomic atomic<br>在系统自动生成 setter_getter 方法的前提下（手动实现只起到提示的作用），两者之间的区别在于 atomic  会在 setter 方法整个 set 逻辑外层加互斥锁（等锁_释放锁都会有开销），保证 set 动作是原子的；而 nonatomic 则不会加锁，在多线程情况下同时调用 setter 方法会有数据混乱的风险。<br>另外，atomic 不能保证线程安全，还需要手动加锁。在单核CPU中可以保证读写安全；在多核CPU中，一可能存在多个响应在不同线程中对同一变量调用 setter 方法；二在单个响应的同时，可能会有另一个周期性的任务在另一个线程中也调用 setter 方法；在同一时间点，不同时间点调用 setter 方法。</p>
</li>
</ul>

      
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2018/06/03/Extension Category/" class="article-date">
  <time datetime="2018-06-03T08:26:37.000Z" itemprop="datePublished">2018-06-03</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2018/06/09/NSTimer/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          NSTimer
        
      </div>
    </a>
  
  
    <a href="/2018/05/27/访问 以及修改私有属性 下午5.42.09/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">访问 以及修改私有属性</div>
    </a>
  
</nav>


  
</article>






  <section id="comments" class="comments">
    <div id="valine_container"></div>
  </section>



      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/WaiKitHsu"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="/atom.xml"><span class="fa fa-rss"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>Let is be.</p>


      </div>
    </footer>

      




  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  <script>
      var GUEST_INFO = ['nick','mail','link'];
      var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
      });
      var notify = 'false' == true;
      var verify = 'false' == true;
      var valine = new Valine();
      valine.init({
          el: '#valine_container',
          notify: notify,
          verify: verify,
          appId: "2mPvqXM2072yhqf09kUxyPtz-gzGzoHsz",
          appKey: "wnLa7vN27K4vtXe3AiqTCkYG",
          placeholder: "have a nice day ~",
          pageSize:'10',
          avatar:'hide',
          lang:'zh-cn'
      })
  </script>


<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
