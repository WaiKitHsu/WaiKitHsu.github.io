<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>uwkit&#39;site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-27T14:14:36.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WaiKitHsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>访问 以及修改私有属性</title>
    <link href="http://yoursite.com/2018/05/27/%E8%AE%BF%E9%97%AE%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/05/27/访问以及修改私有属性/</id>
    <published>2018-05-27T14:10:50.000Z</published>
    <updated>2018-05-27T14:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="访问-以及修改私有属性"><a href="#访问-以及修改私有属性" class="headerlink" title="访问 以及修改私有属性"></a>访问 以及修改私有属性</h5><ol><li><code>KVC</code><br><code>setValue:forKey:</code><br><code>valueForKey:</code></li><li><code>runtime</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A *a = [[A alloc]init];</span><br><span class="line"></span><br><span class="line">unsigned int count = 0;</span><br><span class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">Ivar ivar = ivars[i];</span><br><span class="line"></span><br><span class="line">// 取得属性名并转成字符串类型</span><br><span class="line">const char *ivarName = ivar_getName(ivar);</span><br><span class="line">NSLog(@&quot;%s&quot;,ivarName);</span><br><span class="line"></span><br><span class="line">Ivar firstIvar = ivars[0];</span><br><span class="line">// 修改属性值</span><br><span class="line">object_setIvar(a, firstIvar, @&quot;aaa&quot;);</span><br><span class="line">NSLog(@&quot;%@&quot;,object_getIvar(a, firstIvar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="KVC键值编码"><a href="#KVC键值编码" class="headerlink" title="KVC键值编码"></a><code>KVC</code>键值编码</h5><p>是一种可以通过<code>key</code>属性名来访问类属性的机制，而不是通过调用<code>setter</code> <code>getter</code>方法来访问。同时支持类对象和内建基本数据类型，以及集合运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//动态读取</span><br><span class="line">valueForKey:用于简单路径</span><br><span class="line">valueForKeyPath: 用于复合路径，xx.xx</span><br><span class="line">valueForUndefinedKey 默认实现是抛出异常，可重写这个函数做错误处理</span><br><span class="line"></span><br><span class="line">//动态设置</span><br><span class="line">setValue:forKey:</span><br><span class="line">setValue:forKeyPath:</span><br><span class="line">setValue:forUnderfinedKey:</span><br><span class="line">setNilValueForKey: 对非类对象属性设置nil时调用，默认抛出异常。</span><br><span class="line"></span><br><span class="line">//键值验证</span><br><span class="line">- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class="line"></span><br><span class="line">//集合运算符，作为一个特殊的KeyPath参数传入</span><br><span class="line">格式：集合路径.@+集合运算符.属性keyPath</span><br><span class="line">//简单运算符</span><br><span class="line">@avg， @count ， @max ， @min ，@sum</span><br><span class="line">//对象运算符，以数组形式返回</span><br><span class="line">@distinctUnionOfObjects，@unionOfObjects</span><br><span class="line">//Array和Set操作符，针对的是集合中包含集合的情况</span><br><span class="line">@distinctUnionOfArrays，@unionOfArrays，@distinctUnionOfSets</span><br></pre></td></tr></table></figure></p><h6 id="属性读取查找规则"><a href="#属性读取查找规则" class="headerlink" title="属性读取查找规则"></a>属性读取查找规则</h6><ul><li>动态设置</li></ul><ol><li>首先搜索<code>setKey:</code>方法。</li><li>上面的<code>setter</code>方法没找到，如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>。那么按 <code>_key</code>，<code>_isKey</code>（只针对布尔值有效），<code>key</code>，<code>iskey</code>的顺序搜索成员名。（<code>NSKeyValueCodingCatogery</code>中实现的类方法，默认实现为返回YES）</li><li>如果没有找到成员变量，调用<code>setValue:forUnderfinedKey:</code></li></ol><ul><li>动态读取</li></ul><ol><li>首先按<code>getKey</code>，<code>key</code>，<code>isKey</code>的顺序查找<code>getter</code>方法，找到直接调用。如果是<code>BOOL</code>、<code>Int</code>等内建值类型，会做<code>NSNumber</code>的转换。</li><li>上面的<code>getter</code>没找到，查找<code>countOfKey</code>、<code>objectInKeyAtindex</code>、<code>KeyAtindexes</code>格式的方法。如果<code>countOfKey</code>和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法。</li><li>还没找到，查找<code>countOfKey</code>、<code>enumeratorOfKey</code>、<code>memberOfKey</code>格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。</li><li>还是没找到，如果类方法<code>accessInstanceVariablesDirectly</code>返回YES。那么按 <code>_key</code>，<code>_isKey</code>，<code>key</code>，<code>iskey</code>的顺序搜索成员名。</li><li>再没找到，调用<code>valueForUndefinedKey</code>。</li></ol><h5 id="KVO键值监听"><a href="#KVO键值监听" class="headerlink" title="KVO键值监听"></a><code>KVO</code>键值监听</h5><p>是一种观察者模式，提供了一种当被监听对象（通常是数据模型）属性被修改的时候为其注册监听的对象就能及时得到通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注册</span><br><span class="line">addObserver: forKeyPath: options:  context:</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">removeObserver: forKeyPath</span><br><span class="line">removeObserver: forKeyPath: context:</span><br><span class="line"></span><br><span class="line">//回调</span><br><span class="line">observeValueForKeyPath: ofObject: change: context:</span><br></pre></td></tr></table></figure></p><h6 id="isa-swizzling-KVC-KVO实现原理"><a href="#isa-swizzling-KVC-KVO实现原理" class="headerlink" title="isa-swizzling KVC/KVO实现原理"></a><code>isa-swizzling</code> <code>KVC/KVO</code>实现原理</h6><ul><li>注册监听<blockquote><p>将被观察对象的<code>isa</code>指针指向该类的一个派生类，在这个创建的派生类中重写基类中任何被观察属性的 setter 方法。而派生类在被重写的 setter 方法实现真正的通知机制。同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。<br><a href="http://blog.csdn.net/kesalin/article/details/8194240" target="_blank" rel="noopener">详解键值观察（KVO）及其实现机理</a></p></blockquote></li></ul><ol><li><p>重写 <code>setter</code>，增加的方法以通知系统属性值已经改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通知系统key对应的属性值即将/已经发生改变</span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure></li><li><p>重写<code>class</code>，返回跟未建立监听之前一样的结果，之后动态修改<code>isa</code>的指向。</p></li></ol><ul><li>删除监听<br>将<code>isa</code>指向原先的类对象中。</li></ul><h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><ul><li><p><code>id</code><br>是一个<code>objc_object</code>结构类型的指针，指向类实例。<br><code>typedef struct objc_object *id;</code></p></li><li><p><code>objc_object</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Class</code><br>是一个<code>objc_class</code>结构类型的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">Class _Nullable super_class</span><br><span class="line">const char * _Nonnull name</span><br><span class="line">long version</span><br><span class="line">long info</span><br><span class="line">long instance_size</span><br><span class="line">struct objc_ivar_list * _Nullable ivars</span><br><span class="line">struct objc_method_list * _Nullable * _Nullable</span><br><span class="line">struct objc_cache * _Nonnull cache</span><br><span class="line">struct objc_protocol_list * _Nullable protocols</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>objc_class</code>继承于<code>objc_object</code>，也就是说一个类也可以说是一个对象。（每一个对象内部都会有一个<code>isa</code>指针，指向该对象的类。当一个消息发送给一个对象后，方法的检查从对象的<code>isa</code>指针开始，实例方法定义在对象的类中，如果在这里没有找到，则到超类中查找。）</li><li>类是一个对象，所以它也会是另一个类的实例，这个类就是元类<code>Meta Class</code>。元类用来表述类对象本身所具备的元数据，类方法就定义在这里。（当一个类方法被调用后，先查找自身，如果没有就会从继承链中查找。）</li><li>元类同时也是一个根元类<code>root meta class</code>的实例。根元类的<code>super_class</code>指向<code>NSObject</code>，<code>isa</code>指向自身。<code>NSObject</code>的<code>super_class</code>指向<code>nil</code>。</li></ol><p>[image:625EAC88-993D-4FF5-B59A-575C72CCE704-733-000018D695DE54DD/class-diagram.jpg]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;访问-以及修改私有属性&quot;&gt;&lt;a href=&quot;#访问-以及修改私有属性&quot; class=&quot;headerlink&quot; title=&quot;访问 以及修改私有属性&quot;&gt;&lt;/a&gt;访问 以及修改私有属性&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;KVC&lt;/code&gt;&lt;br&gt;&lt;code&gt;se
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应链</title>
    <link href="http://yoursite.com/2018/05/26/%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>http://yoursite.com/2018/05/26/响应链/</id>
    <published>2018-05-26T13:49:42.000Z</published>
    <updated>2018-05-26T13:50:25.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="响应者对象"><a href="#响应者对象" class="headerlink" title="响应者对象"></a>响应者对象</h5><p>指可以接收并处理事件的对象。 <code>UIResponder</code> 是所有响应者对象的基类。</p><p>而在一下几种情况下不能接收事件：</p><ol><li><code>view.userInteractionEnabled = NO</code> 不与用户交互</li><li><code>view.hidden = NO</code> 隐藏</li><li><code>view.alpha = 0</code> 透明</li><li>正常情况下，对子视图在父视图之外的区域不会被识别</li></ol><h5 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h5><p>是一系列连接在一起的响应者对象，它允许响应者对象将处理事件的责任传递给其他更高级别的对象。随着程序寻找能够处理事件的对象，事件就在响应者链中向上传递。<br>事件的传递是从上到下的，事件的响应是从下到上的。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ol><li>可以通过重写<code>hitTest:withEvent:</code>设置事件处理的传递链，自己处理或者往后传递给其他响应者处理，甚至到最后<code>UIApplication</code>都不处理就丢弃事件。也可以让当前响应对象和它的下一响应对象同时对一次点击对象作出处理。</li><li>可以通过<code>pointInside: withEvent:</code>判断点是否被当前的响应者处理，也可以通过重写该方法更改响应对象的响应热区。</li></ol><h5 id="UIResponder响应者类"><a href="#UIResponder响应者类" class="headerlink" title="UIResponder响应者类"></a><code>UIResponder</code>响应者类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//获取下一个响应者</span><br><span class="line">- (UIResponder*)nextResponder;</span><br><span class="line"></span><br><span class="line">//当它放弃对象响应者,可以设置自身成为第一响应者,默认为NO</span><br><span class="line">- (BOOL)canBecomeFirstResponder;</span><br><span class="line"></span><br><span class="line">//设置第一响应者</span><br><span class="line">- (BOOL)becomeFirstResponder;</span><br><span class="line"></span><br><span class="line">//如果一个对象可以放弃对象响应者就返回YES,默认返回YES</span><br><span class="line">- (BOOL)canResignFirstResponder;</span><br><span class="line"></span><br><span class="line">//放弃第一响应者</span><br><span class="line">- (BOOL)resignFirstResponder;</span><br><span class="line"></span><br><span class="line">//是否是第一响应者</span><br><span class="line">- (BOOL)isFirstResponder;</span><br></pre></td></tr></table></figure><p>一般响应的几种事件</p><ol><li><code>Touch Events</code>触摸事件</li><li><code>Press Events</code>点按事件</li><li><code>Motion Events</code>运动事件</li><li><code>RemoteControl Events</code>远程事件</li></ol><h5 id="从用户触屏开始到图形系统更新屏幕来响应结束"><a href="#从用户触屏开始到图形系统更新屏幕来响应结束" class="headerlink" title="从用户触屏开始到图形系统更新屏幕来响应结束"></a>从用户触屏开始到图形系统更新屏幕来响应结束</h5><ol><li>用户触屏</li><li>硬件报告触摸事件给<code>UIKit</code>框架</li><li><code>UIKit</code>框架将触摸事件打包成<code>UIEvent</code>对象，同时分发给适合的视图<code>Event Handing</code></li><li>视图中的事件处理代码可能进行以下的动作来响应：改变视图或者其子视图的属性；调用 <code>setNeedsLayout</code> 方法以标记该视图或者其子视图需要进行布局更新；调用 <code>setNeedsDisplay</code> 或者 <code>setNeedsDisplayInRect</code> 以标记该视图或者其子视图需要进行重画；通知一个控制器关于一些数据的更新</li><li>如果一个视图的几何结构改变了，<code>UIKit</code>会根据以下几条规则来更新它的子视图：自动重设尺寸 <code>Layout Changes Automatically Using Autoresizing Rules</code>；实现 <code>ayoutSubviews</code>  在定制视图中覆盖这个方法同时用它来调整任何子视图的位置和大小</li><li>如果任何视图的任何部分被标记为需要重画，UIKit 会要求视图重画自身<code>drawRect：</code></li><li>任何已经更新的视图会与应用余下的可视内容组合到一起，同时被发送到图形硬件去显示</li><li>图形硬件将已解释内容转化到屏幕上</li></ol><h5 id="事件的产生和传递"><a href="#事件的产生和传递" class="headerlink" title="事件的产生和传递"></a>事件的产生和传递</h5><p>事件产生之后，系统会将改时间加入到一个由<code>UIApplication</code>管理的事件队列中（队列先进先出）。<br><code>UIApplication</code>会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常会先发送到<code>Window</code>。</p><h5 id="Event-Handing事件分发"><a href="#Event-Handing事件分发" class="headerlink" title="Event Handing事件分发"></a><code>Event Handing</code>事件分发</h5><p>相应的路线：<br><code>First Responser -- &gt; The Window -- &gt;The Application -- &gt; App Delegate</code></p><ul><li><code>First Responser</code>指的是当前接收事件的响应者对象，即当前正在与用户进行交互。事件分发就是为了找出第一响应者，使其有机会首先处理事件。如果它没有进行处理，系统就会将事件传递给下一个响应者。</li><li>事件如果没有得到处理或者没有找到第一响应者，该事件就会沿着响应链往上回溯，到最后<code>UIApplication</code>都不处理就丢弃事件。</li><li>如果当前的<code>view</code>是控制器的<code>view</code>，那么控制器就是上一个响应者；如果当前的<code>view</code>不是控制器的<code>view</code>，那么父控件就是上一个响应者。</li></ul><h5 id="UIGestureRecognizer手势识别器"><a href="#UIGestureRecognizer手势识别器" class="headerlink" title="UIGestureRecognizer手势识别器"></a><code>UIGestureRecognizer</code>手势识别器</h5><p>是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势。便于触摸事件的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UITapGestureRecognizer    //敲击</span><br><span class="line">UIPinchGestureRecognizer    //捏合，缩放</span><br><span class="line">UIRotationGestureRecognizer    //旋转</span><br><span class="line">UISwipeGestureRecognizer    //轻扫</span><br><span class="line">UIPanGestureRecognizer    //拖拽</span><br><span class="line">UIScreenEdgePanGestureRecognizer    //屏幕边缘侧滑</span><br><span class="line">UILongPressGestureRecognizer    //长按</span><br></pre></td></tr></table></figure></p><p>当有两个相关联的手势存在时，可以使用<code>[B requireGestureRecognizerToFail: A]</code>指定A手势在B手势确定失败了之后才触发。</p><h6 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a><code>UITouch</code></h6><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的<code>UITouch</code>对象。<br>当手指移动时，系统不会创建一个新的<code>UITouch</code>对象，而是更新其属性使之能一直保存着相关的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回触摸的位置，该位置是针对触摸的 view 的坐标系，当传入参数为 nil 时，返回的是 window 的位置。</span><br><span class="line">- locationInView:</span><br><span class="line">//返回前一个触摸点的位置。</span><br><span class="line">- previousLocationInView:</span><br></pre></td></tr></table></figure></p><h6 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a><code>UIEvent</code></h6><p>每产生一个事件，就会产生一个<code>UIEvent</code>对象。可以通过<code>allTouches</code>方法获取得到触摸点的集合，可以判断多点触摸事件（单点触摸<code>touches</code>中只有一个<code>UITouch</code>）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;响应者对象&quot;&gt;&lt;a href=&quot;#响应者对象&quot; class=&quot;headerlink&quot; title=&quot;响应者对象&quot;&gt;&lt;/a&gt;响应者对象&lt;/h5&gt;&lt;p&gt;指可以接收并处理事件的对象。 &lt;code&gt;UIResponder&lt;/code&gt; 是所有响应者对象的基类。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2018/05/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/05/26/单例模式/</id>
    <published>2018-05-26T07:17:22.000Z</published>
    <updated>2018-05-26T07:23:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。通常采用懒加载的方式在第一次用到实例的时候再去创建它。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>保证在程序运行过程中，一个类只有一个实例且易于外界访问，从而方便地控制了实例个数，并节约系统资源</p><h5 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h5><p>统一管理资源或共享一份资源。比如，登录控制器，网络数据请求等。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol><li>保证在程序运行过程中，一个类只有一个实例且易于外界访问，从而方便地控制了实例个数，并节约系统资源。</li><li>类控制了实例化过程，所以类可以更加灵活修改实例化过程。<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6></li><li>单例对象一旦建立，对象指针是在保存在静态区的，单例对象在堆中分配的内存空间，会在应用程序终止之后才会被释放。</li><li>不使用于变化的对象，如果同一类型的对象总是要在不同的用例场景中发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li><li>单例类无法继承，因此很难进行类的扩展</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol><li>只有一个实例存在<code>static</code></li><li>只分配一次内存 <code>alloc</code></li><li>考虑线程安全</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (LocationManager *)sharedLocationManager;</span><br><span class="line"></span><br><span class="line">static LocationManager *_shareLocationManager;</span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">//避免每次线程过来都加锁，先判断一次，如果为空才会继续加锁并创建对象</span><br><span class="line">if(_shareLocationManager == nil) &#123;</span><br><span class="line">//避免出现多个线程同时创建_instance,加锁</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">//使用懒加载，确保_instance 只创建一次</span><br><span class="line">if(_shareLocationManager == nil) &#123;</span><br><span class="line">_shareLocationManager = [super allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每次获取实例都会进行判断是否需要创建实例。</li><li>不加同步锁是线程不安全的，比如，有两个线程同时获取实例，A在创建实例中还没有创建完成，B通过判断也进行创建，单例的控制就会在并发的情况下失效。</li><li>加锁容易引起效率降低，在加锁之前先进行判断，当需要创建对象时再加锁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (LocationManager *)sharedLocationManager;</span><br><span class="line"></span><br><span class="line">static LocationManager *_shareLocationManager;</span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">_shareLocationManager = [super allocWithZone:zone];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>声明一个静态变量去保存类的实例，确保它在类中的全局可用性。</li><li>声明一个静态变量 <code>dispatch_once_t</code>，它确保初始化代码只执行一次。</li><li>使用<code>dispatch_once</code>执行初始化的<code>blokc</code>，一旦类已经被初始化，初始化器将永远不会再被调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (LocationManager *)sharedLocationManager &#123;</span><br><span class="line">return [[self alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone &#123;</span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>sharedLocationManager</code>  <code>alloc</code>  <code>copy</code>的时候，将得到的实例都是一样的。</p><h6 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h6><ol><li>修饰局部变量<br>保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存，生命周期类似全局变量，但是作用域不变。</li><li>修饰全局变量<br>使得全局变量的作用域仅限于当前的文件内部，即只有当前文件内部才能访问该全局变量。</li><li>默认初始化为0<br>在静态数据区，内存中的所有字节默认值都是<code>0x00</code>。</li><li>修饰函数<br>被修饰的函数被称为静态函数。</li></ol><h6 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a><code>alloc</code></h6><ol><li><code>alloc</code>调用了<code>allocWithZone:</code>，在系统中分配内存并返回这段内存的指针。</li><li><code>alloc</code>只执行一次。而<code>init</code>会从继承链的顶部开始执行，因为需要先初始化<code>[super init]</code>，所以会自上而下执行多次。</li><li>将申请空间中的值都设置为0。</li></ol><h6 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h6><ol><li>指某个函数在、函数库在多线程环境中被调用时，能正确地处理多个线程之间的共享变量，使得程序功能能正确完成。</li><li>线程安全是相对于多线程而言的，单线程下不会存在线程安全问题，因为单线程下的执行顺序是确定的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。通常采用懒加载的方式在第一次用到实例的时候再去创建它。&lt;/p&gt;
&lt;h5 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/05/12/hello-world/"/>
    <id>http://yoursite.com/2018/05/12/hello-world/</id>
    <published>2018-05-12T05:20:53.000Z</published>
    <updated>2018-05-12T06:23:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>hi~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hi~&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
