<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>uwkit&#39;site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-03T08:28:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WaiKitHsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/06/03/Extension%20Category/"/>
    <id>http://yoursite.com/2018/06/03/Extension Category/</id>
    <published>2018-06-03T02:37:15.000Z</published>
    <updated>2018-06-03T08:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: Extension Category<br>date: 2018-06-03 16:26:37<br>tags:</p><hr><h5 id="Extension-拓展-匿名分类"><a href="#Extension-拓展-匿名分类" class="headerlink" title="Extension 拓展/匿名分类"></a>Extension 拓展/匿名分类</h5><p>是在编译期决议，作为类的一部分。它在编译期和头文件里以及实现文件中的内容一起形成一个完整的类。</p><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul><li>可以声明方法、属性、成员变量</li><li>一般用于声明私有方法、私有属性、私有成员变量</li><li>只存在于一个.h文件中，或只寄生于一个类的.m文件中，例如<code>@interface ViewController () ... @end</code>（常用）</li><li>必须要有一个类的源码才能添加一个类的拓展，对于一些系统的类，可以通过创建子类添加拓展</li></ul><hr><h5 id="Category-分类-类别"><a href="#Category-分类-类别" class="headerlink" title="Category 分类/类别"></a>Category 分类/类别</h5><p>是在运行时决议，在不改变原有类的情况下，动态地进行方法_协议_属性的添加，以适应不同情况下的需求。</p><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><ul><li>可以添加实例方法、类方法，甚至可以实现协议、添加属性（不会生成 setter / getter 方法）</li><li>不可以添加实例变量</li><li>一般用于声明私有方法、私有属性、私有成员变量</li><li>只存在于一个.h文件中，或只寄生于一个类的.m文件中，例如<code>@interface ViewController () ... @end</code>（常用）</li><li>必须要有一个类的源码才能添加一个类的拓展，对于一些系统的类，可以通过创建子类添加拓展</li></ul><h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><ul><li>给现有的类添加方法</li><li>把类的实现根据不同功能组织分开在几个不同的文件中，减少单个文件的体积，按需加载</li><li>声明私有方法</li></ul><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>不建议复写系统类的方法。添加的方法和类中原有的方法同名时，category 会优先调用 category 中的方法。（两者同时存在于方法列表中，在运行时方法的调用由编译器决定，最后参与编译的会被调用）优先级为 分类 &gt; 本类 &gt; 父类。<br>严格意义上来讲，category 中的 load 同普通方法也会对主类中的 load 造成覆盖，只不过 runtime 在自动调用主类和分类中的 load 是直接使用各自方法的指针进行调用的（手动调用时调用的则是分类中的 load 方法）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//分类结构体 可以添加实例方法、类方法，甚至可以实现协议、添加属性</span><br><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"> </span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>加载分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _read_images</span><br><span class="line">* Perform initial processing of the headers in the linked </span><br><span class="line">* list beginning with headerList. </span><br><span class="line">*</span><br><span class="line">* Called by: map_images_nolock</span><br><span class="line">*</span><br><span class="line">* Locking: runtimeLock acquired by map_images</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // Discover categories. </span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process this category. </span><br><span class="line">            // First, register the category with its target class. 将 category 和它的主类/父类注册到哈希表中</span><br><span class="line">            // Then, rebuild the class&apos;s method lists (etc) if  the class is realized. 如果主类/父类已经实现，重建它的方法列表</span><br><span class="line">  // 协议被同时整合到主类和元类</span><br><span class="line">        // 主类对应实例方法和属性，元类对应类方法</span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(&quot;IMAGE TIMES: discover categories&quot;);</span><br><span class="line"></span><br><span class="line">    // Category discovery MUST BE LAST to avoid potential races </span><br><span class="line">    // when other threads call the new category code before </span><br><span class="line">    // this thread finishes its fixups.</span><br><span class="line"></span><br><span class="line">    // +load handled by prepare_load_methods()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用 <code>remethodizeClass(cls-&gt;ISA());</code>重新整理类的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* remethodizeClass</span><br><span class="line">* Attach outstanding categories to an existing class.</span><br><span class="line">* Fixes up cls&apos;s method list, protocol list, and property list. 整合方法/属性/协议</span><br><span class="line">* Updates method caches for cls and its subclasses. 更新类的数据字段</span><br><span class="line">* Locking: runtimeLock must be held by the caller</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>attachCategories(cls, cats, true /*flush caches*/);</code>真正进行处理的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">fixupMethodList(method_list_t *mlist, bool bundleCopy, bool sort)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    assert(!mlist-&gt;isFixedUp());</span><br><span class="line"></span><br><span class="line">    // fixme lock less in attachMethodLists ?</span><br><span class="line">    sel_lock();</span><br><span class="line">    </span><br><span class="line">    // Unique selectors in list.</span><br><span class="line">    for (auto&amp; meth : *mlist) &#123;</span><br><span class="line">        const char *name = sel_cname(meth.name);</span><br><span class="line">        meth.name = sel_registerNameNoLock(name, bundleCopy);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sel_unlock();</span><br><span class="line"></span><br><span class="line">    // Sort by selector address.</span><br><span class="line">    if (sort) &#123;</span><br><span class="line">        method_t::SortBySELAddress sorter;</span><br><span class="line">        std::stable_sort(mlist-&gt;begin(), mlist-&gt;end(), sorter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Mark method list as uniqued and sorted</span><br><span class="line">    mlist-&gt;setFixedUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void </span><br><span class="line">prepareMethodLists(Class cls, method_list_t **addedLists, int addedCount, </span><br><span class="line">                   bool baseMethods, bool methodsFromBundle)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">    // Don&apos;t scan redundantly</span><br><span class="line">    bool scanForCustomRR = !cls-&gt;hasCustomRR();</span><br><span class="line">    bool scanForCustomAWZ = !cls-&gt;hasCustomAWZ();</span><br><span class="line"></span><br><span class="line">    // There exist RR/AWZ special cases for some class&apos;s base methods. </span><br><span class="line">    // But this code should never need to scan base methods for RR/AWZ: </span><br><span class="line">    // default RR/AWZ cannot be set before setInitialized().</span><br><span class="line">    // Therefore we need not handle any special cases here.</span><br><span class="line">    if (baseMethods) &#123;</span><br><span class="line">        assert(!scanForCustomRR  &amp;&amp;  !scanForCustomAWZ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Add method lists to array.</span><br><span class="line">    // Reallocate un-fixed method lists.</span><br><span class="line">    // The new methods are PREPENDED to the method list array.</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; addedCount; i++) &#123;</span><br><span class="line">        method_list_t *mlist = addedLists[i];</span><br><span class="line">        assert(mlist);</span><br><span class="line"></span><br><span class="line">        // Fixup selectors if necessary</span><br><span class="line">        if (!mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">            fixupMethodList(mlist, methodsFromBundle, true/*sort*/);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Scan for method implementations tracked by the class&apos;s flags</span><br><span class="line">        if (scanForCustomRR  &amp;&amp;  methodListImplementsRR(mlist)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomRR();</span><br><span class="line">            scanForCustomRR = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (scanForCustomAWZ  &amp;&amp;  methodListImplementsAWZ(mlist)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomAWZ();</span><br><span class="line">            scanForCustomAWZ = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Attach method lists and properties and protocols from categories to a class. 将类中的方法和分类中新添加的方法/属性/协议整合成到一个相应新的列表中</span><br><span class="line">// Assumes the categories in cats are all loaded and sorted by load order, oldest categories first. 按加载顺序进行排序，最旧的首先被加载，也就是存在复写时调用的是最后一个被加载的</span><br><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ul><li><p>属性<br>@property 声明的变量，在类中创建默认会自动生成一个以下划线为开头的成员变量以及 setter/getter 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//objc_property_t 是一个指向 objc_property 结构体的指针</span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">typedef struct property_t *objc_property_t;</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//获取所有属性</span><br><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">class_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">objc_property_t *</span><br><span class="line">class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        if (outCount) *outCount = 0;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwlock_reader_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    property_t **result = nil;</span><br><span class="line">    unsigned int count = rw-&gt;properties.count();</span><br><span class="line">    if (count &gt; 0) &#123;</span><br><span class="line">        result = (property_t **)malloc((count + 1) * sizeof(property_t *));</span><br><span class="line"></span><br><span class="line">        count = 0;</span><br><span class="line">        for (auto&amp; prop : rw-&gt;properties) &#123;</span><br><span class="line">            result[count++] = &amp;prop;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (outCount) *outCount = count;</span><br><span class="line">    return (objc_property_t *)result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//属性特性</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char * _Nonnull name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char * _Nonnull value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br><span class="line"></span><br><span class="line">//获取属性名</span><br><span class="line">property_getName</span><br><span class="line">//获取属性特性描述字符串</span><br><span class="line">property_getAttributes</span><br><span class="line">//获取所有属性特性</span><br><span class="line">property_copyAttributeList</span><br><span class="line">//获取相应属性特性的 value</span><br><span class="line">property_copyAttributeValue</span><br></pre></td></tr></table></figure></li><li><p>成员变量<br>在 @interface 括号中的统称为成员变量，用于内部，无需与外界进行接触，因此它不会生成 setter/getter 方法。默认修饰是 assign （仅把目标内存区域指针赋值给变量，而内存区域的引用计数器不发生变化）</p></li><li><p>实例变量<br>是成员变量中的一种，是由类定义的变量。实例是针对类而言，是指类的声明。成员变量中除开基本数据类型（int/float..）变量，其他都是实例变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Ivar 指向一个 objc_ivar 结构体</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char * _Nullable ivar_name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    char * _Nullable ivar_type                               OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 获取指定名称的成员变量</span><br><span class="line">class_getInstanceVariable</span><br><span class="line">//@return A pointer to an \c Ivar data structure containing information about the class variable specified by \e name.</span><br><span class="line">class_getClassVariable</span><br><span class="line">// 获取所有成员变量</span><br><span class="line">class_copyIvarList</span><br><span class="line"></span><br><span class="line">// 获取成员变量名</span><br><span class="line">ivar_getName</span><br><span class="line">// 获取成员变量类型编码</span><br><span class="line">ivar_getTypeEncoding</span><br><span class="line">//获取实例变量的偏移值，当一个类被编译后，实例变量的内存布局就形成了（访问实例变量的位置），当系统检测到该类与父类发生重叠时就会调整新添加的实例变量的位置，以变量所占空间为依据产生位移。</span><br><span class="line">/**</span><br><span class="line">@note For instance variables of type \c id or other object types, call \c object_getIvar</span><br><span class="line"> *  and \c object_setIvar instead of using this offset to access the instance variable data directly.</span><br><span class="line">对于 id 或者其他对象类型的变量，调用 object_getIvar / object_setIvar 代替使用</span><br><span class="line">*/</span><br><span class="line">ivar_getOffset</span><br><span class="line"></span><br><span class="line">// 获取某个对象成员变量的值</span><br><span class="line">object_getIvar</span><br><span class="line">// 设置某个对象成员变量的值</span><br><span class="line">object_setIvar</span><br></pre></td></tr></table></figure></li><li><p>nonatomic atomic<br>在系统自动生成 setter_getter 方法的前提下（手动实现只起到提示的作用），两者之间的区别在于 atomic  会在 setter 方法整个 set 逻辑外层加互斥锁（等锁_释放锁都会有开销），保证 set 动作是原子的；而 nonatomic 则不会加锁，在多线程情况下同时调用 setter 方法会有数据混乱的风险。<br>另外，atomic 不能保证线程安全，还需要手动加锁。在单核CPU中可以保证读写安全；在多核CPU中，一可能存在多个响应在不同线程中对同一变量调用 setter 方法；二在单个响应的同时，可能会有另一个周期性的任务在另一个线程中也调用 setter 方法；在同一时间点，不同时间点调用 setter 方法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: Extension Category&lt;br&gt;date: 2018-06-03 16:26:37&lt;br&gt;tags:&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;Extension-拓展-匿名分类&quot;&gt;&lt;a href=&quot;#Extension-拓展-匿名分类&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/05/27/%E8%AE%BF%E9%97%AE%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/05/27/访问以及修改私有属性/</id>
    <published>2018-05-27T14:10:50.000Z</published>
    <updated>2018-06-03T08:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 访问 以及修改私有属性<br>date: 2018-05-27 22:10:50<br>tags:</p><hr><h5 id="访问-以及修改私有属性："><a href="#访问-以及修改私有属性：" class="headerlink" title="访问 以及修改私有属性："></a>访问 以及修改私有属性：</h5><ol><li><code>KVC</code><br><code>setValue:forKey:</code><br><code>valueForKey:</code></li><li><code>runtime</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A *a = [[A alloc]init];</span><br><span class="line"></span><br><span class="line">unsigned int count = 0;</span><br><span class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">Ivar ivar = ivars[i];</span><br><span class="line"></span><br><span class="line">// 取得属性名并转成字符串类型</span><br><span class="line">const char *ivarName = ivar_getName(ivar);</span><br><span class="line">NSLog(@&quot;%s&quot;,ivarName);</span><br><span class="line"></span><br><span class="line">Ivar firstIvar = ivars[0];</span><br><span class="line">// 修改属性值</span><br><span class="line">object_setIvar(a, firstIvar, @&quot;aaa&quot;);</span><br><span class="line">NSLog(@&quot;%@&quot;,object_getIvar(a, firstIvar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="KVC键值编码"><a href="#KVC键值编码" class="headerlink" title="KVC键值编码"></a><code>KVC</code>键值编码</h5><p>是一种可以通过<code>key</code>属性名来访问类属性的机制，而不是通过调用<code>setter</code> <code>getter</code>方法来访问。同时支持类对象和内建基本数据类型，以及集合运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//动态读取</span><br><span class="line">valueForKey:用于简单路径</span><br><span class="line">valueForKeyPath: 用于复合路径，xx.xx</span><br><span class="line">valueForUndefinedKey 默认实现是抛出异常，可重写这个函数做错误处理</span><br><span class="line"></span><br><span class="line">//动态设置</span><br><span class="line">setValue:forKey:</span><br><span class="line">setValue:forKeyPath:</span><br><span class="line">setValue:forUnderfinedKey:</span><br><span class="line">setNilValueForKey: 对非类对象属性设置nil时调用，默认抛出异常。</span><br><span class="line"></span><br><span class="line">//键值验证</span><br><span class="line">- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class="line"></span><br><span class="line">//集合运算符，作为一个特殊的KeyPath参数传入</span><br><span class="line">格式：集合路径.@+集合运算符.属性keyPath</span><br><span class="line">//简单运算符</span><br><span class="line">@avg， @count ， @max ， @min ，@sum</span><br><span class="line">//对象运算符，以数组形式返回</span><br><span class="line">@distinctUnionOfObjects，@unionOfObjects</span><br><span class="line">//Array和Set操作符，针对的是集合中包含集合的情况</span><br><span class="line">@distinctUnionOfArrays，@unionOfArrays，@distinctUnionOfSets</span><br></pre></td></tr></table></figure></p><h6 id="属性读取查找规则"><a href="#属性读取查找规则" class="headerlink" title="属性读取查找规则"></a>属性读取查找规则</h6><ul><li>动态设置</li></ul><ol><li>首先搜索<code>setKey:</code>方法。</li><li>上面的<code>setter</code>方法没找到，如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>。那么按 <code>_key</code>，<code>_isKey</code>（只针对布尔值有效），<code>key</code>，<code>iskey</code>的顺序搜索成员名。（<code>NSKeyValueCodingCatogery</code>中实现的类方法，默认实现为返回YES）</li><li>如果没有找到成员变量，调用<code>setValue:forUnderfinedKey:</code></li></ol><ul><li>动态读取</li></ul><ol><li>首先按<code>getKey</code>，<code>key</code>，<code>isKey</code>的顺序查找<code>getter</code>方法，找到直接调用。如果是<code>BOOL</code>、<code>Int</code>等内建值类型，会做<code>NSNumber</code>的转换。</li><li>上面的<code>getter</code>没找到，查找<code>countOfKey</code>、<code>objectInKeyAtindex</code>、<code>KeyAtindexes</code>格式的方法。如果<code>countOfKey</code>和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法。</li><li>还没找到，查找<code>countOfKey</code>、<code>enumeratorOfKey</code>、<code>memberOfKey</code>格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。</li><li>还是没找到，如果类方法<code>accessInstanceVariablesDirectly</code>返回YES。那么按 <code>_key</code>，<code>_isKey</code>，<code>key</code>，<code>iskey</code>的顺序搜索成员名。</li><li>再没找到，调用<code>valueForUndefinedKey</code>。</li></ol><h5 id="KVO键值监听"><a href="#KVO键值监听" class="headerlink" title="KVO键值监听"></a><code>KVO</code>键值监听</h5><p>是一种观察者模式，提供了一种当被监听对象（通常是数据模型）属性被修改的时候为其注册监听的对象就能及时得到通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注册</span><br><span class="line">addObserver: forKeyPath: options:  context:</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">removeObserver: forKeyPath</span><br><span class="line">removeObserver: forKeyPath: context:</span><br><span class="line"></span><br><span class="line">//回调</span><br><span class="line">observeValueForKeyPath: ofObject: change: context:</span><br></pre></td></tr></table></figure></p><h6 id="isa-swizzling-KVC-KVO实现原理"><a href="#isa-swizzling-KVC-KVO实现原理" class="headerlink" title="isa-swizzling KVC/KVO实现原理"></a><code>isa-swizzling</code> <code>KVC/KVO</code>实现原理</h6><ul><li>注册监听<blockquote><p>将被观察对象的<code>isa</code>指针指向该类的一个派生类，在这个创建的派生类中重写基类中任何被观察属性的 setter 方法。而派生类在被重写的 setter 方法实现真正的通知机制。同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。<br><a href="http://blog.csdn.net/kesalin/article/details/8194240" target="_blank" rel="noopener">详解键值观察（KVO）及其实现机理</a></p></blockquote></li></ul><ol><li><p>重写 <code>setter</code>，增加的方法以通知系统属性值已经改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通知系统key对应的属性值即将/已经发生改变</span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure></li><li><p>重写<code>class</code>，返回跟未建立监听之前一样的结果，之后动态修改<code>isa</code>的指向。</p></li></ol><ul><li>删除监听<br>将<code>isa</code>指向原先的类对象中。</li></ul><h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><ul><li><p><code>id</code><br>是一个<code>objc_object</code>结构类型的指针，指向类实例。<br><code>typedef struct objc_object *id;</code></p></li><li><p><code>objc_object</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Class</code><br>是一个<code>objc_class</code>结构类型的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">Class _Nullable super_class</span><br><span class="line">const char * _Nonnull name</span><br><span class="line">long version</span><br><span class="line">long info</span><br><span class="line">long instance_size</span><br><span class="line">struct objc_ivar_list * _Nullable ivars</span><br><span class="line">struct objc_method_list * _Nullable * _Nullable</span><br><span class="line">struct objc_cache * _Nonnull cache</span><br><span class="line">struct objc_protocol_list * _Nullable protocols</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>objc_class</code>继承于<code>objc_object</code>，也就是说一个类也可以说是一个对象。（每一个对象内部都会有一个<code>isa</code>指针，指向该对象的类。当一个消息发送给一个对象后，方法的检查从对象的<code>isa</code>指针开始，实例方法定义在对象的类中，如果在这里没有找到，则到超类中查找。）</li><li>类是一个对象，所以它也会是另一个类的实例，这个类就是元类<code>Meta Class</code>。元类用来表述类对象本身所具备的元数据，类方法就定义在这里。（当一个类方法被调用后，先查找自身，如果没有就会从继承链中查找。）</li><li>元类同时也是一个根元类<code>root meta class</code>的实例。根元类的<code>super_class</code>指向<code>NSObject</code>，<code>isa</code>指向自身。<code>NSObject</code>的<code>super_class</code>指向<code>nil</code>。</li></ol><p><img src="%E8%AE%BF%E9%97%AE%20%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%EF%BC%9A/class-diagram.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 访问 以及修改私有属性&lt;br&gt;date: 2018-05-27 22:10:50&lt;br&gt;tags:&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;访问-以及修改私有属性：&quot;&gt;&lt;a href=&quot;#访问-以及修改私有属性：&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/05/26/%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>http://yoursite.com/2018/05/26/响应链/</id>
    <published>2018-05-26T13:49:42.000Z</published>
    <updated>2018-06-03T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 响应链<br>date: 2018-05-26 21:49:42<br>tags:</p><hr><h5 id="响应者对象"><a href="#响应者对象" class="headerlink" title="响应者对象"></a>响应者对象</h5><p>指可以接收并处理事件的对象。 <code>UIResponder</code> 是所有响应者对象的基类。</p><p>而在一下几种情况下不能接收事件：</p><ol><li><code>view.userInteractionEnabled = NO</code> 不与用户交互</li><li><code>view.hidden = NO</code> 隐藏</li><li><code>view.alpha = 0</code> 透明</li><li>正常情况下，对子视图在父视图之外的区域不会被识别</li></ol><h5 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h5><p>是一系列连接在一起的响应者对象，它允许响应者对象将处理事件的责任传递给其他更高级别的对象。随着程序寻找能够处理事件的对象，事件就在响应者链中向上传递。<br>事件的传递是从上到下的，事件的响应是从下到上的。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ol><li>可以通过重写<code>hitTest:withEvent:</code>设置事件处理的传递链，自己处理或者往后传递给其他响应者处理，甚至到最后<code>UIApplication</code>都不处理就丢弃事件。也可以让当前响应对象和它的下一响应对象同时对一次点击对象作出处理。</li><li>可以通过<code>pointInside: withEvent:</code>判断点是否被当前的响应者处理，也可以通过重写该方法更改响应对象的响应热区。</li></ol><h5 id="UIResponder响应者类"><a href="#UIResponder响应者类" class="headerlink" title="UIResponder响应者类"></a><code>UIResponder</code>响应者类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//获取下一个响应者</span><br><span class="line">- (UIResponder*)nextResponder;</span><br><span class="line"></span><br><span class="line">//当它放弃对象响应者,可以设置自身成为第一响应者,默认为NO</span><br><span class="line">- (BOOL)canBecomeFirstResponder;</span><br><span class="line"></span><br><span class="line">//设置第一响应者</span><br><span class="line">- (BOOL)becomeFirstResponder;</span><br><span class="line"></span><br><span class="line">//如果一个对象可以放弃对象响应者就返回YES,默认返回YES</span><br><span class="line">- (BOOL)canResignFirstResponder;</span><br><span class="line"></span><br><span class="line">//放弃第一响应者</span><br><span class="line">- (BOOL)resignFirstResponder;</span><br><span class="line"></span><br><span class="line">//是否是第一响应者</span><br><span class="line">- (BOOL)isFirstResponder;</span><br></pre></td></tr></table></figure><p>一般响应的几种事件</p><ol><li><code>Touch Events</code>触摸事件</li><li><code>Press Events</code>点按事件</li><li><code>Motion Events</code>运动事件</li><li><code>RemoteControl Events</code>远程事件</li></ol><h5 id="从用户触屏开始到图形系统更新屏幕来响应结束"><a href="#从用户触屏开始到图形系统更新屏幕来响应结束" class="headerlink" title="从用户触屏开始到图形系统更新屏幕来响应结束"></a>从用户触屏开始到图形系统更新屏幕来响应结束</h5><ol><li>用户触屏</li><li>硬件报告触摸事件给<code>UIKit</code>框架</li><li><code>UIKit</code>框架将触摸事件打包成<code>UIEvent</code>对象，同时分发给适合的视图<code>Event Handing</code></li><li>视图中的事件处理代码可能进行以下的动作来响应：改变视图或者其子视图的属性；调用 <code>setNeedsLayout</code> 方法以标记该视图或者其子视图需要进行布局更新；调用 <code>setNeedsDisplay</code> 或者 <code>setNeedsDisplayInRect</code> 以标记该视图或者其子视图需要进行重画；通知一个控制器关于一些数据的更新</li><li>如果一个视图的几何结构改变了，<code>UIKit</code>会根据以下几条规则来更新它的子视图：自动重设尺寸 <code>Layout Changes Automatically Using Autoresizing Rules</code>；实现 <code>ayoutSubviews</code>  在定制视图中覆盖这个方法同时用它来调整任何子视图的位置和大小</li><li>如果任何视图的任何部分被标记为需要重画，UIKit 会要求视图重画自身<code>drawRect：</code></li><li>任何已经更新的视图会与应用余下的可视内容组合到一起，同时被发送到图形硬件去显示</li><li>图形硬件将已解释内容转化到屏幕上</li></ol><h5 id="事件的产生和传递"><a href="#事件的产生和传递" class="headerlink" title="事件的产生和传递"></a>事件的产生和传递</h5><p>事件产生之后，系统会将改时间加入到一个由<code>UIApplication</code>管理的事件队列中（队列先进先出）。<br><code>UIApplication</code>会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常会先发送到<code>Window</code>。</p><h5 id="Event-Handing事件分发"><a href="#Event-Handing事件分发" class="headerlink" title="Event Handing事件分发"></a><code>Event Handing</code>事件分发</h5><p>相应的路线：<br><code>First Responser -- &gt; The Window -- &gt;The Application -- &gt; App Delegate</code></p><ul><li><code>First Responser</code>指的是当前接收事件的响应者对象，即当前正在与用户进行交互。事件分发就是为了找出第一响应者，使其有机会首先处理事件。如果它没有进行处理，系统就会将事件传递给下一个响应者。</li><li>事件如果没有得到处理或者没有找到第一响应者，该事件就会沿着响应链往上回溯，到最后<code>UIApplication</code>都不处理就丢弃事件。</li><li>如果当前的<code>view</code>是控制器的<code>view</code>，那么控制器就是上一个响应者；如果当前的<code>view</code>不是控制器的<code>view</code>，那么父控件就是上一个响应者。</li></ul><h5 id="UIGestureRecognizer手势识别器"><a href="#UIGestureRecognizer手势识别器" class="headerlink" title="UIGestureRecognizer手势识别器"></a><code>UIGestureRecognizer</code>手势识别器</h5><p>是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势。便于触摸事件的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UITapGestureRecognizer    //敲击</span><br><span class="line">UIPinchGestureRecognizer    //捏合，缩放</span><br><span class="line">UIRotationGestureRecognizer    //旋转</span><br><span class="line">UISwipeGestureRecognizer    //轻扫</span><br><span class="line">UIPanGestureRecognizer    //拖拽</span><br><span class="line">UIScreenEdgePanGestureRecognizer    //屏幕边缘侧滑</span><br><span class="line">UILongPressGestureRecognizer    //长按</span><br></pre></td></tr></table></figure></p><p>当有两个相关联的手势存在时，可以使用<code>[B requireGestureRecognizerToFail: A]</code>指定A手势在B手势确定失败了之后才触发。</p><h6 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a><code>UITouch</code></h6><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的<code>UITouch</code>对象。<br>当手指移动时，系统不会创建一个新的<code>UITouch</code>对象，而是更新其属性使之能一直保存着相关的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回触摸的位置，该位置是针对触摸的 view 的坐标系，当传入参数为 nil 时，返回的是 window 的位置。</span><br><span class="line">- locationInView:</span><br><span class="line">//返回前一个触摸点的位置。</span><br><span class="line">- previousLocationInView:</span><br></pre></td></tr></table></figure></p><h6 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a><code>UIEvent</code></h6><p>每产生一个事件，就会产生一个<code>UIEvent</code>对象。可以通过<code>allTouches</code>方法获取得到触摸点的集合，可以判断多点触摸事件（单点触摸<code>touches</code>中只有一个<code>UITouch</code>）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 响应链&lt;br&gt;date: 2018-05-26 21:49:42&lt;br&gt;tags:&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;响应者对象&quot;&gt;&lt;a href=&quot;#响应者对象&quot; class=&quot;headerlink&quot; title=&quot;响应者对象&quot;&gt;&lt;/a&gt;响应者对象
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/05/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/05/26/单例模式/</id>
    <published>2018-05-26T07:17:22.000Z</published>
    <updated>2018-06-03T08:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 单例模式 Singleton<br>date: 2018-05-26 15:17:22<br>tags:</p><hr><p>单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。通常采用懒加载的方式在第一次用到实例的时候再去创建它。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>保证在程序运行过程中，一个类只有一个实例且易于外界访问，从而方便地控制了实例个数，并节约系统资源</p><h5 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h5><p>统一管理资源或共享一份资源。比如，登录控制器，网络数据请求等。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol><li>保证在程序运行过程中，一个类只有一个实例且易于外界访问，从而方便地控制了实例个数，并节约系统资源。</li><li>类控制了实例化过程，所以类可以更加灵活修改实例化过程。<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6></li><li>单例对象一旦建立，对象指针是在保存在静态区的，单例对象在堆中分配的内存空间，会在应用程序终止之后才会被释放。</li><li>不使用于变化的对象，如果同一类型的对象总是要在不同的用例场景中发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li><li>单例类无法继承，因此很难进行类的扩展</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol><li>只有一个实例存在<code>static</code></li><li>只分配一次内存 <code>alloc</code></li><li>考虑线程安全</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (LocationManager *)sharedLocationManager;</span><br><span class="line"></span><br><span class="line">static LocationManager *_shareLocationManager;</span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">//避免每次线程过来都加锁，先判断一次，如果为空才会继续加锁并创建对象</span><br><span class="line">if(_shareLocationManager == nil) &#123;</span><br><span class="line">//避免出现多个线程同时创建_instance,加锁</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">//使用懒加载，确保_instance 只创建一次</span><br><span class="line">if(_shareLocationManager == nil) &#123;</span><br><span class="line">_shareLocationManager = [super allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每次获取实例都会进行判断是否需要创建实例。</li><li>不加同步锁是线程不安全的，比如，有两个线程同时获取实例，A在创建实例中还没有创建完成，B通过判断也进行创建，单例的控制就会在并发的情况下失效。</li><li>加锁容易引起效率降低，在加锁之前先进行判断，当需要创建对象时再加锁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (LocationManager *)sharedLocationManager;</span><br><span class="line"></span><br><span class="line">static LocationManager *_shareLocationManager;</span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">_shareLocationManager = [super allocWithZone:zone];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>声明一个静态变量去保存类的实例，确保它在类中的全局可用性。</li><li>声明一个静态变量 <code>dispatch_once_t</code>，它确保初始化代码只执行一次。</li><li>使用<code>dispatch_once</code>执行初始化的<code>blokc</code>，一旦类已经被初始化，初始化器将永远不会再被调用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (LocationManager *)sharedLocationManager &#123;</span><br><span class="line">return [[self alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone &#123;</span><br><span class="line">return _shareLocationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>sharedLocationManager `</code>alloc<code></code>copy`的时候，将得到的实例都是一样的。</p><h6 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h6><ol><li>修饰局部变量<br>保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存，生命周期类似全局变量，但是作用域不变。</li><li>修饰全局变量<br>使得全局变量的作用域仅限于当前的文件内部，即只有当前文件内部才能访问该全局变量。</li><li>默认初始化为0<br>在静态数据区，内存中的所有字节默认值都是<code>0x00</code>。</li><li>修饰函数<br>被修饰的函数被称为静态函数。</li></ol><h6 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a><code>alloc</code></h6><ol><li><code>alloc</code>调用了<code>allocWithZone:</code>，在系统中分配内存并返回这段内存的指针。</li><li><code>alloc</code>只执行一次。而<code>init</code>会从继承链的顶部开始执行，因为需要先初始化<code>[super init]</code>，所以会自上而下执行多次。</li><li>将申请空间中的值都设置为0。</li></ol><h6 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h6><ol><li>指某个函数在、函数库在多线程环境中被调用时，能正确地处理多个线程之间的共享变量，使得程序功能能正确完成。</li><li>线程安全是相对于多线程而言的，单线程下不会存在线程安全问题，因为单线程下的执行顺序是确定的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 单例模式 Singleton&lt;br&gt;date: 2018-05-26 15:17:22&lt;br&gt;tags:&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。通常采用懒加载的方式在第一次用到实例的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/05/12/hello-world/"/>
    <id>http://yoursite.com/2018/05/12/hello-world/</id>
    <published>2018-05-12T05:20:53.000Z</published>
    <updated>2018-05-12T06:23:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>hi~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hi~&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
